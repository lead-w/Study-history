<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js基础 | NorthUnicorn</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/Study-history/assets/css/0.styles.e2241fa8.css" as="style"><link rel="preload" href="/Study-history/assets/js/app.a1ad6491.js" as="script"><link rel="preload" href="/Study-history/assets/js/35.ba4dfc73.js" as="script"><link rel="prefetch" href="/Study-history/assets/js/10.7e604d29.js"><link rel="prefetch" href="/Study-history/assets/js/11.3067a7ca.js"><link rel="prefetch" href="/Study-history/assets/js/12.d1a6fe69.js"><link rel="prefetch" href="/Study-history/assets/js/13.4864be39.js"><link rel="prefetch" href="/Study-history/assets/js/14.30636de0.js"><link rel="prefetch" href="/Study-history/assets/js/15.2bcbbae8.js"><link rel="prefetch" href="/Study-history/assets/js/16.9d7f8d82.js"><link rel="prefetch" href="/Study-history/assets/js/17.0b328dfe.js"><link rel="prefetch" href="/Study-history/assets/js/18.f73ae9e0.js"><link rel="prefetch" href="/Study-history/assets/js/19.0e9a993e.js"><link rel="prefetch" href="/Study-history/assets/js/2.d8f505d4.js"><link rel="prefetch" href="/Study-history/assets/js/20.1a0bbb82.js"><link rel="prefetch" href="/Study-history/assets/js/21.23696e8c.js"><link rel="prefetch" href="/Study-history/assets/js/22.0c73380e.js"><link rel="prefetch" href="/Study-history/assets/js/23.c3ff09bc.js"><link rel="prefetch" href="/Study-history/assets/js/24.7933ac39.js"><link rel="prefetch" href="/Study-history/assets/js/25.c8ae28e2.js"><link rel="prefetch" href="/Study-history/assets/js/26.3736bb12.js"><link rel="prefetch" href="/Study-history/assets/js/27.97f3f560.js"><link rel="prefetch" href="/Study-history/assets/js/28.fa4268d5.js"><link rel="prefetch" href="/Study-history/assets/js/29.50a00a75.js"><link rel="prefetch" href="/Study-history/assets/js/3.8796f9d7.js"><link rel="prefetch" href="/Study-history/assets/js/30.25371944.js"><link rel="prefetch" href="/Study-history/assets/js/31.b1b8fd04.js"><link rel="prefetch" href="/Study-history/assets/js/32.f534b2b4.js"><link rel="prefetch" href="/Study-history/assets/js/33.b9e3298a.js"><link rel="prefetch" href="/Study-history/assets/js/34.8ac7105e.js"><link rel="prefetch" href="/Study-history/assets/js/36.ef19edf1.js"><link rel="prefetch" href="/Study-history/assets/js/37.0f9caf07.js"><link rel="prefetch" href="/Study-history/assets/js/38.2e4a8c9a.js"><link rel="prefetch" href="/Study-history/assets/js/39.46f87030.js"><link rel="prefetch" href="/Study-history/assets/js/4.c59777f9.js"><link rel="prefetch" href="/Study-history/assets/js/40.e1794eae.js"><link rel="prefetch" href="/Study-history/assets/js/41.5507fc07.js"><link rel="prefetch" href="/Study-history/assets/js/42.caa5814b.js"><link rel="prefetch" href="/Study-history/assets/js/43.6cd8bb3f.js"><link rel="prefetch" href="/Study-history/assets/js/44.2442f75f.js"><link rel="prefetch" href="/Study-history/assets/js/45.9648c0bd.js"><link rel="prefetch" href="/Study-history/assets/js/46.de6e3a74.js"><link rel="prefetch" href="/Study-history/assets/js/47.72c2c6ba.js"><link rel="prefetch" href="/Study-history/assets/js/48.d5004b5b.js"><link rel="prefetch" href="/Study-history/assets/js/49.a2d1d664.js"><link rel="prefetch" href="/Study-history/assets/js/5.9b395665.js"><link rel="prefetch" href="/Study-history/assets/js/50.19b7d6c9.js"><link rel="prefetch" href="/Study-history/assets/js/51.a9a0da08.js"><link rel="prefetch" href="/Study-history/assets/js/52.e99771cc.js"><link rel="prefetch" href="/Study-history/assets/js/53.74e55a43.js"><link rel="prefetch" href="/Study-history/assets/js/54.c4ff7ebc.js"><link rel="prefetch" href="/Study-history/assets/js/55.acadfba7.js"><link rel="prefetch" href="/Study-history/assets/js/56.8fa49260.js"><link rel="prefetch" href="/Study-history/assets/js/57.08f5f4e4.js"><link rel="prefetch" href="/Study-history/assets/js/58.9d13dd4c.js"><link rel="prefetch" href="/Study-history/assets/js/6.d5fd31a3.js"><link rel="prefetch" href="/Study-history/assets/js/7.ec2eb6b8.js"><link rel="prefetch" href="/Study-history/assets/js/8.91dd34c9.js"><link rel="prefetch" href="/Study-history/assets/js/9.814e5587.js">
    <link rel="stylesheet" href="/Study-history/assets/css/0.styles.e2241fa8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Study-history/" class="home-link router-link-active"><!----> <span class="site-name">NorthUnicorn</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Study-history/front/" class="nav-link router-link-active">front</a></div><div class="nav-item"><a href="/Study-history/houduan/" class="nav-link">back</a></div><div class="nav-item"><a href="/Study-history/devOps/" class="nav-link">devOps</a></div><div class="nav-item"><a href="/Study-history/interview/" class="nav-link">interview</a></div><div class="nav-item"><a href="/Study-history/article/" class="nav-link">article</a></div><div class="nav-item"><a href="https://github.com/songge7777" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Study-history/front/" class="nav-link router-link-active">front</a></div><div class="nav-item"><a href="/Study-history/houduan/" class="nav-link">back</a></div><div class="nav-item"><a href="/Study-history/devOps/" class="nav-link">devOps</a></div><div class="nav-item"><a href="/Study-history/interview/" class="nav-link">interview</a></div><div class="nav-item"><a href="/Study-history/article/" class="nav-link">article</a></div><div class="nav-item"><a href="https://github.com/songge7777" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>front</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Study-history/front/css.html" class="sidebar-link">css技巧汇总</a></li><li><a href="/Study-history/front/js.html" class="sidebar-link">js</a></li><li><a href="/Study-history/front/react.html" class="sidebar-link">react 汇总</a></li><li><a href="/Study-history/front/vue.html" class="sidebar-link">vue 汇总</a></li><li><a href="/Study-history/front/vuepress.html" class="sidebar-link">vuepress</a></li><li><a href="/Study-history/front/phone.html" class="sidebar-link">移动端</a></li><li><a href="/Study-history/front/webpack.html" class="sidebar-link">webpack(基础)</a></li><li><a href="/Study-history/front/video.html" class="sidebar-link">视频</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>js</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Study-history/front/jsBase.html" class="active sidebar-link">js基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#类型转换" class="sidebar-link">类型转换</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#script-标签" class="sidebar-link">script 标签</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#五种数据类型" class="sidebar-link">五种数据类型</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#二进制操作符号" class="sidebar-link">二进制操作符号</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#一元操作符" class="sidebar-link">一元操作符</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#变量作用域" class="sidebar-link">变量作用域</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#引用类型" class="sidebar-link">引用类型</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#global对象" class="sidebar-link">Global对象</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#创建对象-2" class="sidebar-link">创建对象</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#函数-2" class="sidebar-link">函数</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#this" class="sidebar-link">this</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#window" class="sidebar-link">window</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#dom" class="sidebar-link">DOM</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#dom2" class="sidebar-link">DOM2</a></li><li class="sidebar-sub-header"><a href="/Study-history/front/jsBase.html#事件" class="sidebar-link">事件</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="js基础"><a href="#js基础" aria-hidden="true" class="header-anchor">#</a> js基础</h1> <p></p><div class="table-of-contents"><ul><li><a href="#类型转换">类型转换</a><ul><li><a href="#valueof-tostring">valueOf&amp;&amp;toString</a></li><li><a href="#">+</a></li></ul></li><li><a href="#script-标签">script 标签</a></li><li><a href="#五种数据类型">五种数据类型</a></li><li><a href="#二进制操作符号">二进制操作符号</a></li><li><a href="#一元操作符">一元操作符</a></li><li><a href="#变量作用域">变量作用域</a><ul><li><a href="#延迟作用域链">延迟作用域链</a></li><li><a href="#变量声明">变量声明</a></li></ul></li><li><a href="#引用类型">引用类型</a><ul><li><a href="#创建对象">创建对象</a></li><li><a href="#创建数组">创建数组</a></li><li><a href="#date">Date</a></li><li><a href="#正则">正则</a></li><li><a href="#函数">函数</a></li></ul></li><li><a href="#global对象">Global对象</a></li><li><a href="#创建对象">创建对象</a></li><li><a href="#继承">继承</a></li><li><a href="#函数">函数</a></li><li><a href="#闭包">闭包</a></li><li><a href="#this">this</a></li><li><a href="#window">window</a></li><li><a href="#dom">DOM</a><ul><li><a href="#节点关系">节点关系</a></li><li><a href="#节点操作">节点操作</a></li><li><a href="#document">document</a></li><li><a href="#查找元素">查找元素</a></li><li><a href="#element">Element</a></li><li><a href="#文本">文本</a></li><li><a href="#动态脚本">动态脚本</a></li><li><a href="#动态样式">动态样式</a></li><li><a href="#选择符">选择符</a></li><li><a href="#焦点">焦点</a></li><li><a href="#readystate-属性">readyState 属性</a></li><li><a href="#浏览器模式-document-compatmode">浏览器模式(document.compatMode)</a></li><li><a href="#标签自定义属性">标签自定义属性</a></li><li><a href="#插入标记">插入标记</a></li><li><a href="#scrollintoview-作用于每一个元素">scrollIntoView() 作用于每一个元素</a></li><li><a href="#children-返回元素元素的子节点-文本会过滤掉">children 返回元素元素的子节点 文本会过滤掉</a></li><li><a href="#contains-被检测的节点是后代子节点">contains() 被检测的节点是后代子节点</a></li><li><a href="#comparedocumentposition-返回节点间的位子关系">compareDocumentPosition 返回节点间的位子关系</a></li><li><a href="#插入文本">插入文本</a></li></ul></li><li><a href="#dom2">DOM2</a><ul><li><a href="#style-变化">style 变化</a></li><li><a href="#计算样式">计算样式</a></li><li><a href="#操作样式表">操作样式表</a></li><li><a href="#元素大小">元素大小</a></li><li><a href="#遍历">遍历</a></li></ul></li><li><a href="#事件">事件</a><ul><li><a href="#ui事件">UI事件</a></li><li><a href="#焦点事件-还有其他的不常用具体看书">焦点事件(还有其他的不常用具体看书)</a></li><li><a href="#鼠标事件-具体的看书">鼠标事件(具体的看书)</a></li><li><a href="#键盘事件">键盘事件</a></li><li><a href="#h5事件">h5事件</a></li><li><a href="#事件委托">事件委托</a></li></ul></li></ul></div><p></p> <h2 id="类型转换"><a href="#类型转换" aria-hidden="true" class="header-anchor">#</a> 类型转换</h2> <ul><li>三等不转换数据类型,两等转换数据类型</li> <li>NaN 谁都不和他相等</li> <li>null==undefined null和undefined两个等号相等，三个等号不相等</li> <li>对象 == 字符串 会把对象转成字符串再比较</li> <li>剩余的都转换为数字进行比较</li></ul> <h3 id="valueof-tostring"><a href="#valueof-tostring" aria-hidden="true" class="header-anchor">#</a> valueOf&amp;&amp;toString</h3> <h3 id><a href="#" aria-hidden="true" class="header-anchor">#</a> +</h3> <ul><li>1、两个操作数如果是number则直接相加出结果</li> <li>2、如果其中有一个操作数为string，则将另一个操作数隐式的转换成string,然后在进行字符串拼接出结果</li> <li>3、如果操作的是复杂数据类型,直接将他们转换成字符串,进行拼接</li> <li>4、如果两个操作数是boolean,那么将他们转换成number相加</li> <li>5、比较的时候会转换成数值进行比较</li> <li>几个例子</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 如果操作的是复杂数据类型,直接将他们转换成字符串,进行拼接</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// '',对象相加 转string</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [object Object],对象相加 转string ([]=&gt;'',{}=&gt;[object Object])  </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// [object Object],注意js把()中的语句当做一个表达式,因此{}不能被理解为语句块,被理解成一个对象</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">+</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [object Object][object Object] </span>
</code></pre></div><ul><li>布尔</li> <li>比较的时候会转换成数值进行比较</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//false 他们比较的是引用地址值的不同</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//true [].toString() 转换成值是0,![]=&gt;false=&gt;0</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">==</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// false 引用地址不一样</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">==</span><span class="token operator">!</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// false  {} =&gt; [object Object] 所以不等</span>

</code></pre></div><h2 id="script-标签"><a href="#script-标签" aria-hidden="true" class="header-anchor">#</a> script 标签</h2> <ul><li>6个属性 async defer charset language src type</li> <li>注意
<ul><li>1、script 标签内 不能存在字符串 可以加反斜杠转义</li> <li>2、script标签放到head中 js会等head中的js全部被下载和解析后在执行body</li> <li>3、所以一般放到 body内 加快显示时间</li> <li>4、derfer 延迟执行 遇到才会执行,也就是页面都解析完毕后在运行,一般都是先后顺序执行,先于 DOMContentLoad 事件</li> <li>5、async 异步执行 立即下载 执行顺序不是先后 一定会在load事件前执行 可能会在 DOMContentLoad 事件前后执行
他们两个只适应外部脚本</li></ul></li></ul> <h2 id="五种数据类型"><a href="#五种数据类型" aria-hidden="true" class="header-anchor">#</a> 五种数据类型</h2> <ul><li>Undefined Null Boolean Number String(typeof 获取类型值)</li> <li>未定义  undefined</li> <li>布尔值  boolean</li> <li>字符串  string</li> <li>数值    number</li> <li>对象和null object</li> <li>函数    function</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// undefined 定义一个变量 没有赋值</span>
  <span class="token comment">// Null 赋值一个空对象指针</span>
  <span class="token comment">// 用法 只要意在保存对象的变量还没有真正保存对象 就用null</span>
  <span class="token comment">// 都是只有一个值的数据类型</span>
</code></pre></div><ul><li>Boolean 数据类型转换</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 数据类型        转换成true       转换成false</span>
  <span class="token comment">// Boolean          true              false</span>
  <span class="token comment">// String           非空              空字符串('')</span>
  <span class="token comment">// Number           非零(包括无穷大)   0和NaN</span>
  <span class="token comment">// Null             任何对象           null</span>
  <span class="token comment">// Undefined        没有               Undefined</span>
</code></pre></div><ul><li>Number
<ul><li>NaN 非数字的特殊值</li> <li>特点 任何NaN的操作都返回NaN,NaN与任何值都不相等 包括自己</li> <li>isNaN() 将接收的值转换成数值 能返回fasle 否则true</li></ul></li> <li>转换方式
<ul><li>Number()适应任何类型</li> <li>parseInt() 把不同进制的数值(第二个参数,是进制)转换成整数数值
<ul><li>第二个参数 是转换成进制 若转换不了 就返回NAN 默认是10  parseInt(num,1)=&gt;NAN  parseInt(num,2)=&gt;2进制的num转换成整数</li></ul></li> <li>ParseFloat()</li></ul></li> <li>Number转换</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Boolean值 true/1 false/0</span>
<span class="token comment">// null  0</span>
<span class="token comment">// 字符串 </span>
<span class="token comment">//   '001' =&gt; 1</span>
<span class="token comment">//   ''(空) =&gt; 0</span>
<span class="token comment">//   'asd' =&gt; NaN</span>
<span class="token comment">//   '123aaa' =&gt; NaN</span>
<span class="token comment">// 对象</span>
<span class="token comment">//     调用valueOf() 和toString()</span>
<span class="token comment">// ParseInt转换 (第二个参数是进制  默认是10)</span>
<span class="token comment">//   '0001'=&gt; 1</span>
<span class="token comment">//   '123aaa' =&gt; 123</span>
<span class="token comment">//   '' =&gt; NaN</span>
<span class="token comment">//   '22.5' =&gt; 22</span>
<span class="token comment">// ParseFloat(没有第二个参数)转换 </span>
<span class="token comment">//   '1.22.33' =&gt; 1.22</span>
</code></pre></div><ul><li>String
<ul><li>字符串的特点 一旦被创建 他们的值就不变 要是改变的话 原来的字符串要被销毁 然后再用新字段填充</li> <li>转换方式</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// toString() 返回对应字符串的表现(数值 布尔 对象 字符串),可以传递(2,8,16进制)</span>
<span class="token comment">//   null 和 undefined 没有这个方法</span>
<span class="token comment">//   (10).toString(2)  =&gt; 1010,toString传入2将数值转换成2进制的数</span>
<span class="token comment">//   parseInt(1010,2) =&gt; 10,parseInt第二个参数传2,就说明把一个二进制的数转换成整数</span>
<span class="token comment">// String()</span>
<span class="token comment">//   啥都可以转换(null和undefined 没有toString 但是可以用String进行转换)</span>
<span class="token comment">//   如果值有toString 则调用</span>
<span class="token comment">//   String(null)</span>
<span class="token comment">//   值是null 返回 'null' undefined 返回 'undefined'</span>
</code></pre></div><ul><li>object
<ul><li>每个对象都有的方法</li> <li>constructor 保存创建当前对象的函数</li> <li>hasOwnProperty(propertyName) 检查属性在对象实例中(而不是原型链中)</li> <li>toLocaleString() 返回对象的字符串表示 与执行环境有关系</li> <li>toString()</li> <li>ValueOf()</li> <li>in 操作符 对象的属性  不管是实例中还是原型中 ('name' in person)</li> <li>Object.keys(obj),for in 都是用来遍历对象的key(可枚举)</li></ul></li></ul> <h2 id="二进制操作符号"><a href="#二进制操作符号" aria-hidden="true" class="header-anchor">#</a> 二进制操作符号</h2> <ul><li>二进制码:就是二进制数</li> <li>二进制反码:将二进制的0取1,1取0</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 按位非~ </span>
  <span class="token comment">//   计算规则:操作数的负数减一</span>
  <span class="token comment">//     将1(这里叫：原码)转二进制 ＝ 00000001</span>
  <span class="token comment">//     按位取反 ＝ 11111110</span>
  <span class="token comment">//     发现符号位(即最高位)为1(表示负数)，将除符号位之外的其他数字取反 ＝ 10000001</span>
  <span class="token comment">//     末位加1取其补码 ＝ 10000010</span>
  <span class="token comment">//     转换回十进制 ＝ -2</span>
  <span class="token comment">// 按位与(&amp;)  </span>
  <span class="token comment">//     计算规则:操作数二进制对齐 都是1返回1 其他返回0</span>
  <span class="token comment">//     010&amp;101=&gt;000</span>
  <span class="token comment">// 按位或(|)</span>
  <span class="token comment">//     计算规则:操作数二进制对齐 只要是1返回1 都是0返回0</span>
  <span class="token comment">//     0110|1001 =&gt; 1111</span>
  <span class="token comment">// 按位异或(^)</span>
  <span class="token comment">//     计算规则:操作数二进制对齐 只要有一个1就返回1 (00 11)都返回0</span>
  <span class="token comment">//     (用法:1和0对取)</span>
  <span class="token comment">//     1^1 =&gt;0</span>
  <span class="token comment">//     0^1 =&gt;1</span>
  <span class="token comment">// 左移(&lt;&lt;)</span>
  <span class="token comment">//     计算规则:所有操作数向左边移动指定的位数(不影响符号)</span>
  <span class="token comment">//     3&lt;&lt;2  =&gt; 12 </span>
  <span class="token comment">// 右移</span>
  <span class="token comment">//     有符号,保留符号(&gt;&gt;)</span>
  <span class="token comment">//       计算规则:所有操作数向右边边移动指定的位数(与左移相反)</span>
  <span class="token comment">//     没符号,不保留符号(&gt;&gt;&gt;)</span>
  <span class="token comment">//       (64)&gt;&gt;&gt;5 =&gt; 2 这个正常</span>
  <span class="token comment">//       (-64)&gt;&gt;&gt;5 =&gt; 13427726 这个数很大  因为负数的二进制码 当整数的二进制码  一起移动(包括最高位的1)</span>
  
</code></pre></div><ul><li>布尔值
<ul><li>逻辑非!
<ul><li>!false =&gt; true</li> <li>!0 =&gt; true</li></ul></li> <li>逻辑与&amp;&amp;
<ul><li>属于短路操作(重点),第一个值能决定就不会执行第二个值(第一个值是false 就不会执行第二个值)</li> <li>true &amp;&amp; false =&gt; false</li></ul></li> <li>逻辑或||
<ul><li>有一个为true即返回true,同样是一个短路操作 第一个参数为true后面不会执行</li></ul></li></ul></li></ul> <h2 id="一元操作符"><a href="#一元操作符" aria-hidden="true" class="header-anchor">#</a> 一元操作符</h2> <ul><li>+(- 同理) 对应非数字会像Number()一样对值进行转换
<ul><li>+'01' =&gt; 1</li> <li><ul><li>'z' =&gt; NaN</li></ul></li> <li>加法如果有一个操作数是字符串
<ul><li>2个都是 就拼接起来</li> <li>只有一个 将另一个转换成字符串在拼接</li></ul></li> <li>如果 是别的类型则调toString和valueOf 对于undefined和null 调用String</li></ul></li> <li>逗号操作符 返回最后一个
<ul><li>var num = (1,2,3,4) //num==4</li></ul></li> <li>if() 里面都会调用Boolean()转换</li> <li>do{}while() 语句至少会执行一次</li> <li>while(){}</li> <li>for in 用来枚举对象的属性</li> <li>label 语句在代码中添加标签(多个for循环用)
<ul><li>break 退出后面的循环</li> <li>continue 退出当前循环</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// outermost:</span>
<span class="token comment">// for(let i=0;i&lt;10;i++){</span>
<span class="token comment">//   for(let j=0;j&lt;10;j++){</span>
<span class="token comment">//       if(i==5&amp;&amp;j==5){</span>
<span class="token comment">//         break outermost,//(55)</span>
<span class="token comment">//         // continue outermost,//(95)</span>
<span class="token comment">//       }</span>
<span class="token comment">//       num++</span>
<span class="token comment">//   } </span>
<span class="token comment">// }</span>
<span class="token comment">// console.log(num)</span>
</code></pre></div><ul><li>with(){} 将代码的作用域 设置到一个特定的对象中</li> <li>switch 语句</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// switch(i){</span>
<span class="token comment">//   case '2':</span>
<span class="token comment">//     // 合并使用(一般备注下)</span>
<span class="token comment">//   case '3':</span>
<span class="token comment">//     console.log('3 or 2')</span>
<span class="token comment">//     break;</span>
<span class="token comment">//     // case值可以是表达式</span>
<span class="token comment">//   case '4'+'5':</span>
<span class="token comment">//     console.log('4'+'5')</span>
<span class="token comment">//     break;</span>
<span class="token comment">//   default:</span>
<span class="token comment">//     break;</span>
<span class="token comment">// }</span>
</code></pre></div><ul><li>函数的参数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// function fn(num1,num2){</span>
  <span class="token comment">// }</span>
  <span class="token comment">// fn(1,2)</span>

  <span class="token comment">// 当fn有传递值的情况下 num1,num2 和arguments 值永远保持同步</span>
  <span class="token comment">// 当fn没有给值的时候 num1,num2 就是undefined,arguments为空没有值  修改任意一个 他们值不同步</span>
</code></pre></div><h2 id="变量作用域"><a href="#变量作用域" aria-hidden="true" class="header-anchor">#</a> 变量作用域</h2> <ul><li>检查类型</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// typeof 一般用来检查 基本数据类型(最佳的工具)</span>
<span class="token comment">//   未定义  undefined</span>
<span class="token comment">//   布尔值  boolean</span>
<span class="token comment">//   字符串  string</span>
<span class="token comment">//   数值    number</span>
<span class="token comment">//   对象和null object</span>
<span class="token comment">//   函数    function</span>
<span class="token comment">// 对象(instanceof)</span>
<span class="token comment">//   obj instanceof Object</span>
<span class="token comment">// 数组</span>
<span class="token comment">//   Array.isArray(arr)</span>
<span class="token comment">//   if(value instanceof Array)// 需要环境</span>
</code></pre></div><ul><li>执行环境定义了变量或函数有权访问其他数据,决定了他们各自的行为,每个执行环境都有一个关联的变量对象</li> <li>在web中,全局执行环境认为是window对象，某个环境中的所有代码执行完成后,该环境被销毁,其中所有变量等 都销毁,全局执行环境直到浏览器关闭才销毁</li> <li>作用域当前访问的权限</li> <li>作用域链保证了对执行环境有权访问所有变量和函数的有序访问</li> <li>作用域在创建的时候 就确定了 不是在执行的时候确定的</li></ul> <h3 id="延迟作用域链"><a href="#延迟作用域链" aria-hidden="true" class="header-anchor">#</a> 延迟作用域链</h3> <ul><li>try-catch 他会创建一个新的变量对象</li> <li>with语句 会将执行对象添加到作用域链中</li> <li>这两个语句都会在作用域链的前端添加一个变量对象</li></ul> <h3 id="变量声明"><a href="#变量声明" aria-hidden="true" class="header-anchor">#</a> 变量声明</h3> <ul><li>使用var 声明的变量会自动被添加到最近的环境中,在函数中就是当前函数的局部环境</li> <li>如果不使用var 则被加到全局环境中</li></ul> <h2 id="引用类型"><a href="#引用类型" aria-hidden="true" class="header-anchor">#</a> 引用类型</h2> <h3 id="创建对象"><a href="#创建对象" aria-hidden="true" class="header-anchor">#</a> 创建对象</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、let obj = new Object()</span>
<span class="token comment">// 2、person={</span>
<span class="token comment">//     name:'sg'</span>
<span class="token comment">//   }</span>
<span class="token comment">// 读取属性</span>
<span class="token comment">//   person.name/person['name']</span>
</code></pre></div><h3 id="创建数组"><a href="#创建数组" aria-hidden="true" class="header-anchor">#</a> 创建数组</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、var colors = new Array(20)// 20 代表的是创建length =20的数组 </span>
<span class="token comment">// 2、var colors = new Array(['red','blue'])</span>
<span class="token comment">// 利用length属性对数组进行增删</span>
<span class="token comment">//   var colors = new Array('red','blue')</span>
<span class="token comment">//   colors.length = 1 // blue就会被删除掉</span>
<span class="token comment">//   colors.length = 2 // ['red','undefined']</span>
</code></pre></div><ul><li>转换方法
<ul><li>toSting()会返回由数组中每个值的字符串形式拼接而成的一个逗号分隔的字符串</li> <li>也等同 join(',')方法 (join 接收undefined 或者空 和接收',' 是一样的,如果是null 就不一样了)</li> <li>var c = ['red','blue']; c.toString() //red,blue</li> <li>valueOf() 同样返回数组本身</li> <li>alert(c)  同样结论,alert要接收字符串参数 默认会调用toString</li></ul></li> <li>数组方法
<ul><li>栈方法(后进先出)
<ul><li>push 将参数逐个添加到数组末尾,修改数组长度</li> <li>pop  删除末尾最后一项 减少length</li></ul></li> <li>队列方法(先进先出)
<ul><li>shift</li> <li>unshift</li></ul></li> <li>重排序方法
<ul><li>reverse 倒序</li> <li>sort
<ul><li>sort((a,b)=&gt;a-b) 返回负值位子不变,返回正值调换位子,返回0位子不变(第一个值位于第二个值前面 返回负数 第二个值位于第一个值前面返回正数)</li></ul></li></ul></li> <li>操作方法
<ul><li>concat 连接 返回新的数组 原数组不变</li> <li>slice('startNumber','endNumber') 包前不包后 返回新的数组 原数组不变</li> <li>splice
<ul><li>删除 (0,2)从第0项开始 删除2个</li> <li>插入 (2,0,'item','item1') 第二项开始,删除0个,插入item和item1</li> <li>返回删除后的内容  原数组变化</li></ul></li></ul></li> <li>位置方法
<ul><li>indexOf()和lastIndexOf()</li> <li>返回查找到的项在数组中的位置,没有查找到就返回-1,查找会用全等去比较</li> <li>第一个参数是要查找的值  第二个参数是查找的起始位置</li></ul></li> <li>迭代方法
<ul><li>every</li> <li>some</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
  <span class="token keyword">var</span> everyRs <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arrary</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>item<span class="token operator">&gt;</span><span class="token number">2</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token boolean">false</span>
  <span class="token keyword">var</span> someRs <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arrary</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>item<span class="token operator">&gt;</span><span class="token number">2</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token boolean">true</span>
</code></pre></div></li> <li>filter<div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
  <span class="token keyword">var</span> filterRs <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>array</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> item<span class="token operator">&gt;</span><span class="token number">2</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
</code></pre></div></li> <li>forEach<div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
  num<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>array</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token comment">//执行某些操作})</span>
</code></pre></div></li> <li>map<div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
  <span class="token keyword">var</span> mapRs <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>array</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> item<span class="token operator">*</span><span class="token number">2</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
</code></pre></div></li> <li>归并方法
reduce&amp;&amp;reduceRight
他们接收4个参数:前一项,当前项,索引,数组对象<div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
  num<span class="token punctuation">,</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span>cur<span class="token punctuation">,</span>index<span class="token punctuation">,</span>array</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//若传递了第二个参数 即index从0开始 pre就是第一个  否则从1开始 cur就是第一个</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li></ul></li></ul> <h3 id="date"><a href="#date" aria-hidden="true" class="header-anchor">#</a> Date</h3> <ul><li>Date.parse() 接收的是字符串不能是number</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 格式 </span>
<span class="token comment">//  月/日/年 =&gt; 6/13/2004</span>
<span class="token comment">//  2004-05-25T00:00:00 </span>
<span class="token comment">//  Date.parse('日期')这个等同于new Date('日期')</span>
</code></pre></div><ul><li>Date.UTC()</li> <li>Date.UTC(年,月，日，时，分，秒) 表示返回当前的毫秒数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 参数  返回时间戳</span>
<span class="token comment">//  年分,基于0月开始(0是一月,1是二月),小时基于0到23 </span>
<span class="token comment">//  年月是必须的</span>
</code></pre></div><ul><li>new Date 接收的参数与Date.UTC 一样</li> <li>Date.now() 表示返回当前的毫秒数 ，返回的都是毫秒数</li> <li>toLocaleString,toString,valueOf方法</li> <li>toLocaleString 和toString大致一样的效果 返回时间</li> <li>valueOf方法 返回日期的毫秒数 可以用操作符来比较日期值</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// var date1 = new Date(2007,0,1)</span>
<span class="token comment">// var date2 = new Date(2007,1,1)</span>
<span class="token comment">// alert(date1&gt;date2) // false</span>
</code></pre></div><ul><li>日期格式化</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// toDateString 显示星期几、月、日、年</span>
<span class="token comment">// toTimeString 时分秒和时区</span>
<span class="token comment">// toUTCString 实现格式化完整的UTC日期</span>
</code></pre></div><ul><li>方法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// getTime/setTime  同valueOf 返回毫秒数/设置毫秒数</span>
<span class="token comment">// getFullYear/setFullYear 取得4位数的年份</span>
<span class="token comment">// getMonth/setMonth 设置月份0开始 11表示十二月/设置超过11则增加年份</span>
<span class="token comment">// getDate/setDate  设置日1开始 / 设置超过31则增加月份</span>
<span class="token comment">// getDay/setDay 设置星期几</span>
<span class="token comment">// getHours/setHours 返回日期的小时数0-23</span>
<span class="token comment">// getMinutes/setMinutes 返回分0-59 </span>
<span class="token comment">// getSeconds/setSeconds 返回秒</span>
<span class="token comment">// getTimezoneOffset 返回本地时间与UTC时间相差分钟数</span>
</code></pre></div><h3 id="正则"><a href="#正则" aria-hidden="true" class="header-anchor">#</a> 正则</h3> <ul><li>创建</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、</span>
<span class="token comment">// var pattern1 = /cat/g</span>
<span class="token comment">// var pattern2 = new RegExp('cat','g')</span>
<span class="token comment">// 注意给RegExp 传递的是字符串,需要对特殊字符进行双重转义</span>
<span class="token comment">//               new 对象里面传递的是字符串  直接写不是字符串</span>
<span class="token comment">//   字面量模式         等价的字符串(即用RegExp创建的参数)</span>
<span class="token comment">// /\[bc\]at/  =&gt;  &quot;\\[bc\\]at&quot;</span>
<span class="token comment">// /\d.\d{1,2}/  =&gt;  &quot;\\d.\\d{1,2}&quot;</span>
<span class="token comment">// /\\hello/   =&gt; '\\\\hello'</span>

<span class="token comment">// 2、</span>
<span class="token comment">// let path = '/user/:uid/:name';</span>
<span class="token comment">// let reg1 = /\:\w+/g</span>
<span class="token comment">//   console.log(reg.source) =&gt; \:\w+</span>
  
<span class="token comment">// // 这里注意 \\w  我们要他的\  里所有的第一个\代表转义 最终我们要得到(\w) 所以就是\\  </span>
<span class="token comment">// let reg2 = new RegExp('\:\\w+', 'g')</span>

<span class="token comment">// let name = '/user/:uid/:name'.match(reg)</span>
</code></pre></div><ul><li>标志
<ul><li>g:表示应用所有字符串,而非在发现第一个匹配后立即停止</li> <li>i:表示不区分大小写</li> <li>m:表示多行模式,即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项</li></ul></li> <li>元字符
<ul><li>所有的元字符都需要转义</li></ul></li> <li>实例属性</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// global 布尔值,表示是否设置了g标志</span>
  <span class="token comment">// ignoreCase 布尔值,表示是否设置了i标志</span>
  <span class="token comment">// lastIndex 整数,表示开始搜索下一个匹配项的字符位置,从0开始(带g才有效果 不然每次都是从头开始)</span>
  <span class="token comment">// multiline 布尔值 表示是否设置了m表示</span>
  <span class="token comment">// source 正则表达式的字符串表示</span>

  <span class="token comment">// var pattern = /\[bc\]at/i;</span>
  <span class="token comment">// console.lo(pattern.global) =&gt; false</span>
  <span class="token comment">// console.lo(pattern.ignoreCase) =&gt; true</span>
  <span class="token comment">// console.lo(pattern.multiline) =&gt; false </span>
  <span class="token comment">// console.lo(pattern.lastIndex) =&gt; 0</span>
  <span class="token comment">// console.lo(pattern.source) =&gt; &quot;\[bc\]at&quot;</span>
</code></pre></div><ul><li>实例方法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// exec 接收一个字符串参数 返回匹配的内容，或者没有匹配项情况下返回null</span>
  <span class="token comment">// 返回的是array实例,记住不能随便加空格,没有捕获组则该数组只包含一项,捕获组就是中括号</span>
  <span class="token comment">//   index 表示匹配项在字符串中的位置</span>
  <span class="token comment">//   input 正则表达式的字符串</span>
  <span class="token comment">//     let text = &quot;mom and dad and bady&quot;</span>
  <span class="token comment">//     var p = /mom( and dad (and bady)?)?/gi</span>
  <span class="token comment">//     var p1 = /nd/gi</span>
  <span class="token comment">//     var ma = p.exec(text)</span>
  <span class="token comment">// 若是不加g他每次只返回一个匹配项,每次调用exec则都会在字符串中继续查找新的匹配项索引的第一个就是匹配到的值</span>
  <span class="token comment">// 若正则匹配项里面加()(即捕获组)则匹配所有满足的  如果带g他的index会有变化</span>
  <span class="token comment">// test 接收一个字符串参数 匹配到内容就返回true 否则就fasle</span>
  <span class="token comment">//   toString方法 </span>
  <span class="token comment">//   RegExp 和 字面量创建的 toString方法都返回正则表达式的字面量</span>
  <span class="token comment">// valueOf 返回正则表达式的本身 是一个对象</span>
</code></pre></div><ul><li>静态属性 (基于最近一次正则表达式操作而变化)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// RegExp 上的方法</span>
<span class="token comment">// $n n代表()内匹配数据</span>
<span class="token comment">// input($_) 最近一次要匹配的字符串</span>
<span class="token comment">// lastMatch($&amp;) 最近一次匹配的结果</span>
<span class="token comment">// lastParent($+) 最近一次匹配的捕获组</span>
<span class="token comment">// leftContext($`) 匹配结果之前的数据</span>
<span class="token comment">// rightContext($') 匹配结果之后的数据</span>
<span class="token comment">// multiline($*) 布尔 表示是否所有表达式都使用多行模式</span>
</code></pre></div><h3 id="函数"><a href="#函数" aria-hidden="true" class="header-anchor">#</a> 函数</h3> <ul><li>内部属性</li> <li>this 看执行环境</li> <li>caller 这个是属性保存着调用当前函数的引用</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// function outer(){</span>
<span class="token comment">//   inner() </span>
<span class="token comment">// }</span>
<span class="token comment">// function inner(){</span>
<span class="token comment">//   alert(inner.caller)</span>
<span class="token comment">//   //console.log(arguments.callee.caller)</span>

<span class="token comment">// }</span>
<span class="token comment">// outer()</span>
</code></pre></div><ul><li>arguments 类数组 包含传入函数中所有的参数</li> <li>arguments.callee callee是一个指针 指向拥有这个arguments对象的函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
  <span class="token keyword">else</span> <span class="token punctuation">{</span>
    retrun <span class="token function">factorial</span><span class="token punctuation">(</span>num<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">// 或者argumeng.callee(num-1)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre></div><ul><li>函数的属性
<ul><li>length 表示函数希望接收的命名参数的个数</li> <li>prototype 属性不可枚举</li> <li>call/apply/bind</li> <li>阶乘 arguments.callee代表的当前的行数</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// function factorial(num){</span>
  <span class="token comment">//   if(num&lt;=1){</span>
  <span class="token comment">//     return 1;</span>
  <span class="token comment">//   }else{</span>
  <span class="token comment">//     return num*arguments.callee(num-1)</span>
  <span class="token comment">//   }</span>
  
  <span class="token comment">// }</span>
</code></pre></div><ul><li>Number</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 方法 (四舍五入)</span>
<span class="token comment">// toFixed(num)</span>
<span class="token comment">// let rs = 10 </span>
<span class="token comment">// console.log(rs.toFixed(2))//10.00</span>
</code></pre></div><ul><li>string</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 方法 访问字符串中特定的方法</span>
<span class="token comment">//   charAt()/charCodeAt() 都接收一个参数</span>
<span class="token comment">//   或者 用中括号加数字</span>
<span class="token comment">// 操作方法</span>
<span class="token comment">//   concat() 连接 可接受多个参数 进行拼接</span>
<span class="token comment">//   slice/substr/substring</span>
<span class="token comment">//     slice和substring 2个参数起始位置</span>
<span class="token comment">//     substr 开始位子和个数</span>
<span class="token comment">//     负值</span>
<span class="token comment">//       slice会将负值与字符串长度相加</span>
<span class="token comment">//       substr 第一个加长度 第二个转换为0</span>
<span class="token comment">//       substring 负值变成0 然后 0和领一个数值换位子 从小到大</span>
<span class="token comment">//     返回操作后的数字 原不变,若第二个不传 则将字符串末尾作为结束位置</span>
<span class="token comment">//   trim 删除前置及后缀的所有空格,然后返回结果,原数组不变</span>
<span class="token comment">//     非标准trimLeft和trimRight</span>
<span class="token comment">//   toLowerCase(转换成小写)和toUpperCase(转换成大写)/toLocalLowerCase和toLacalCase(针对特定的地区实现)</span>
<span class="token comment">//   localeCompare 比较2个字符串</span>
<span class="token comment">//     如果字符串在字母表中应该排在字符串参数之前,返回负数</span>
<span class="token comment">//     如果字符串等于另一个字符串,返回负数</span>
<span class="token comment">//     如果字符串在字母表中应该排在字符串参数之后,返回正数</span>
<span class="token comment">//   indexOf('') lastIndexOf('') 查找返回字符的索引 第二个参数从哪个位子开始找</span>
<span class="token comment">// 字符串匹配的方法</span>
<span class="token comment">//   match</span>
<span class="token comment">//     与exec参数啥都一样</span>
<span class="token comment">//     区别 </span>
<span class="token comment">//       match带g将匹配到的数组放在数组内返回(带不带捕获组都一样)</span>
<span class="token comment">//       exec带g只是index会有变化</span>
<span class="token comment">//   search</span>
  
<span class="token comment">//   replace(字符串/正则,字符串/函数)</span>
<span class="token comment">//     var text = &quot;cat,bat,sat,fat&quot;</span>
<span class="token comment">//     var rs = text.repalce(&quot;at&quot;,&quot;ond&quot;)</span>
<span class="token comment">//     // &quot;cond,bat,sat,fat&quot;</span>
<span class="token comment">//     var rs = text.repalce(/at/g,&quot;ond&quot;)</span>
<span class="token comment">//     // &quot;cond,bond,sond,fond&quot;</span>
<span class="token comment">//   参数 </span>
<span class="token comment">//     第一个参数:字符串或者正则</span>
<span class="token comment">//     第二个参数:字符串或者函数</span>
<span class="token comment">//         函数参数说明</span>
<span class="token comment">//           参一 要匹配的内容,与replace的第一个参数一样</span>
<span class="token comment">//           参二 要匹配的内容对应的位子下标(如果有使用()分组 就返回分组的值,对应的下标就到参数三或者往后排)</span>
<span class="token comment">//           参三 原字符串</span>
<span class="token comment">//           注意:这个函数必须要有一个返回值,否则的话它就会拿undefined替换掉原来的内容</span>
<span class="token comment">//   返回:替换后的新字符串,原来的字符串没有变化</span>
    
<span class="token comment">//   例子</span>
<span class="token comment">//       let str = '123wqeqw123qweqq3232we'</span>
<span class="token comment">//       let r = /(\d+)\w/g</span>
<span class="token comment">//       let rs = str.replace(r,(r1,r2,r3)=&gt;{</span>
<span class="token comment">//         console.log('=====',r1,r2,r3)</span>
<span class="token comment">//       })</span>
<span class="token comment">//   正则表达式 字符串内有一些特殊的字符</span>
<span class="token comment">//     他们是RegExp 对象上的静态方法</span>
<span class="token comment">//     $$  $</span>
<span class="token comment">//     $&amp;  匹配模式的子字符串 与RegExp.lastMatch 的值相同 (lastMatch 最后匹配的值)</span>
<span class="token comment">//       你不能使用属性访问器(RegExp.$&amp;)来使用简写的别名，因为解析器在这里会将 &quot;&amp;&quot; 看做表达式，并抛出 SyntaxError 。使用 方括号符号来访问属性。</span>
<span class="token comment">//     $n  匹配第n个捕获组的子字符串 n(0-9),如果正则表达式没有定义捕获组 则使用空字符串</span>
<span class="token comment">//     $nn 匹配第nn个捕获组的子字符串 nn(00-99)</span>
</code></pre></div><h2 id="global对象"><a href="#global对象" aria-hidden="true" class="header-anchor">#</a> Global对象</h2> <ul><li>URI</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  encodeURI 和 decodeURI 对URI进行编译 有效的URI不能包括空格  而他们就是对空格进行编码和解析(他会对% 空格 等进行转义)</span>
<span class="token comment">//  encodeURIComponent 和 decodeURIComponent 则对任何非标准字符串进行编码</span>
<span class="token comment">// var uri = &quot;http://www.baidu.com/a b&quot;;</span>
<span class="token comment">// console.log(encodeURI(uri)) // http://www.baidu.com/a%20b </span>
<span class="token comment">// console.log(encodeURIComponent(uri)) // http%3A%2F%2Fwww.baidu.com/a%20b </span>
</code></pre></div><ul><li>eval 是一个js解析器 接收一个参数 即要执行的js字符串</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// eval(&quot;alert('hi')&quot;)</span>
<span class="token comment">// eval 中创建的任何变量或函数都不会被提升</span>
<span class="token comment">// 但是在strict严格模式下 eval不能被赋值 &amp;&amp; 外部访问不到eval中创建的任何变量</span>
</code></pre></div><ul><li>对象的属性</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// undefined/NaN/infinity  </span>
<span class="token comment">// Object/Array/Date/Error/RegExp</span>
<span class="token comment">// String</span>
<span class="token comment">// Number</span>
<span class="token comment">// Boolean</span>
<span class="token comment">// Function </span>
<span class="token comment">// js明确禁止给 undefined/NaN/infinity 赋值</span>
</code></pre></div><ul><li>Math</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// min&amp;&amp;max 方法用于确定一组数值的最大值和最小值</span>
<span class="token comment">//   var max = Math.max(3,5,1,22)</span>
<span class="token comment">//   console.log(max) // 22</span>
<span class="token comment">// 借助 apply</span>
<span class="token comment">//   var values = [3,5,1,22]</span>
<span class="token comment">//   var max = Math.max.apply(Math,apply)</span>
<span class="token comment">// 舍入方法</span>
<span class="token comment">//   Math.ceil(25.9) //26 向上舍入</span>
<span class="token comment">//   Math.floor(25.1) //25 向下舍入</span>
<span class="token comment">//   Math.round(25.9) //26 四舍五入</span>
<span class="token comment">// random方法 返回0到1之间的数</span>
<span class="token comment">//   //获取2个数之间的任意数</span>
<span class="token comment">//   function selectFrom(lowerValue,upperValue){</span>
<span class="token comment">//     let choices = upperValue - lowerValue</span>
<span class="token comment">//     return Math.floor(Math.random()*choices + lowerValue)</span>
<span class="token comment">//   }</span>
<span class="token comment">//   selectFrom(2,10)</span>
<span class="token comment">//   //这个函数很有用 可以在数组中随机取一项</span>
<span class="token comment">//   let arr = ['red','green','blue','black']</span>
<span class="token comment">//   var color = arr[selectFrom(0,arr.length-1)]</span>
</code></pre></div><ul><li>面向对象
<ul><li>属性类型:数据类型和访问属性</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 数据属性</span>
<span class="token comment">//     configurable 表示能否通过delete 删除 默认是true</span>
<span class="token comment">//     Enumerable 表示能否通过for-in循环 默认true</span>
<span class="token comment">//     Writable 表示能否修改属性的值 默认true</span>
<span class="token comment">//     Value 读写都要经过这儿 默认是undefined</span>
<span class="token comment">//   要修改属性的默认特征 必须用Object.defineProperty ('属性所在的对象','属性的名字','一个描述符对象')方法, 描述符即上面数据属性(可设置一个或者多个)</span>
<span class="token comment">//   configurable 值一旦被修改成 false 就不能在设置true 会报错的</span>
<span class="token comment">//   如果通过 Object.defineProperty 创建的新属性 如果不指定的情况下 configurable Enumerable Writable 都是false</span>
<span class="token comment">// 访问器属性</span>
<span class="token comment">//   不包含数据值 也就是上面的value,它包含getter和setter</span>
<span class="token comment">//   特征</span>
<span class="token comment">//     configurable 表示能否通过delete 删除 默认是true</span>
<span class="token comment">//     Enumerable 表示能否通过for-in循环 默认true</span>
<span class="token comment">//     get 读取值调用的函数</span>
<span class="token comment">//     set 设置值调用的函数</span>
<span class="token comment">//     var book = {</span>
<span class="token comment">//       _year:2004,</span>
<span class="token comment">//       edition:1</span>
<span class="token comment">//     }</span>
<span class="token comment">//     Object.defineProperty(book,'year',{</span>
<span class="token comment">//       get:function(){</span>
<span class="token comment">//         return this._year</span>
<span class="token comment">//       },</span>
<span class="token comment">//       set:function(val){</span>
<span class="token comment">//         if(val &gt; 2004){</span>
<span class="token comment">//           this._year = val</span>
<span class="token comment">//           this.edition + = val-2004</span>
<span class="token comment">//         }</span>
<span class="token comment">//       }</span>
<span class="token comment">//     })</span>
<span class="token comment">//     book.year = 2005</span>
<span class="token comment">//     console.log(book.edition)</span>
<span class="token comment">// Object.defineProperties('对象',{</span>
<span class="token comment">//   'key1':{},</span>
<span class="token comment">//   'key2':{}</span>
<span class="token comment">// })</span>
</code></pre></div><ul><li>读取属性特征
<ul><li>Object.getOwnPropertyDescriptor('对象','属性') 可以获取属性的特征 也就是上面的配置</li></ul></li></ul> <h2 id="创建对象-2"><a href="#创建对象-2" aria-hidden="true" class="header-anchor">#</a> 创建对象</h2> <ul><li>new Object(null) 不会产生原型链，{} 会产生</li> <li>1、字面量</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//   let obj = new Object()</span>
<span class="token comment">//   缺点:产生大量重复的代码</span>
</code></pre></div><ul><li>2、工场模式</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//   function createObj(){</span>
<span class="token comment">//     let obj = new Object()</span>
<span class="token comment">//     return obj</span>
<span class="token comment">//   } </span>
  
<span class="token comment">//   var a1 = createObj()</span>
<span class="token comment">//   var a2 = createObj()</span>
<span class="token comment">//   缺点:没有解决对象识别问题(怎样知道一个对象的类型)</span>
</code></pre></div><ul><li>3、构造函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//   function Person(name){</span>
<span class="token comment">//     this.name = name</span>
<span class="token comment">//     this.sayName = ()=&gt;{}</span>
<span class="token comment">//   }</span>
<span class="token comment">//   // this.sayName = ()=&gt;{} 等同于 this.sayName = new Function()</span>
<span class="token comment">//   var a1 = new Person('sg')</span>
<span class="token comment">//   缺点:每个方法都要再实例上面重新创建一次</span>
<span class="token comment">//     可以修改</span>
<span class="token comment">//     function Person(name){</span>
<span class="token comment">//       this.name = name</span>
<span class="token comment">//       this.sayName = fn</span>
<span class="token comment">//     }</span>
<span class="token comment">//     function fn(){}</span>
<span class="token comment">//   缺点 每个实例确实只创建了一次fn 但是fn成了全局的了</span>
</code></pre></div><ul><li>4、原型模式</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//   function Person(){</span>
<span class="token comment">//     this.arr = []</span>
<span class="token comment">//   }</span>
<span class="token comment">//   Person.prototype.name = 'sg'</span>
<span class="token comment">//   Person.prototype.fn = ()=&gt;{}</span>
<span class="token comment">//   缺点:问题就是数据共存,SubType的实例都能都是拥有公共的arr</span>
<span class="token comment">// 原型中的方法 (person 是 Person直接new出来的)</span>
    <span class="token comment">// __proto__ 指向 isPrototypeOf 方法的对象 返回true</span>
    <span class="token comment">//   Person.prototype.isPrototypeOf(person) //true/false</span>
    <span class="token comment">//   Object.getPrototypeOf() 获取__proto__</span>
    <span class="token comment">//   Object.getPrototypeOf(person) == Person.prototype</span>
    <span class="token comment">// 对象的constructor属性是用来标识对象类型的  判断实例是否是某构造函数直接生成</span>
    <span class="token comment">//   person.constructor</span>
    <span class="token comment">// 对象的所有实例 </span>
    <span class="token comment">//   person instanceof Object // true</span>
    <span class="token comment">//   person instanceof Person // true</span>
</code></pre></div><ul><li>5、构造函数和原型模式组合</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">//   function Person(name){</span>
    <span class="token comment">//       this.name = name</span>
    <span class="token comment">//   }</span>
    <span class="token comment">//   Person.prototype = {</span>
    <span class="token comment">//     constructor:Person</span>
    <span class="token comment">//     sayName:function(){</span>
    <span class="token comment">//         return this.name</span>
    <span class="token comment">//     }</span>
    <span class="token comment">//   }</span>
</code></pre></div><h2 id="继承"><a href="#继承" aria-hidden="true" class="header-anchor">#</a> 继承</h2> <ul><li>1、原型链</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//   function SuperType(){</span>
<span class="token comment">//     this.arr = []</span>
<span class="token comment">//   }</span>
<span class="token comment">//   function SubType(){}</span>
<span class="token comment">//   SubType.prototype = new SuperType()</span>
<span class="token comment">//   缺点:问题就是数据共存,SubType new出来的 实例都能都是拥有公共的arr</span>
</code></pre></div><ul><li>2、借用构造函数(call/apply)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//   function SuperType(){</span>
<span class="token comment">//     this.arr = []</span>
<span class="token comment">//   }</span>
<span class="token comment">//   function subType(){</span>
<span class="token comment">//     superType.call(this)</span>
<span class="token comment">//     this.fn = ()=&gt;{}</span>
<span class="token comment">//   }</span>
<span class="token comment">//   缺点:方法在构造函数中 无法复用 每次都是重新创建</span>
</code></pre></div><ul><li>3、组合(借用构造函数和原型链)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//   function SuperType(name){</span>
<span class="token comment">//     this.name = name</span>
<span class="token comment">//     this.arr = []</span>
<span class="token comment">//   }</span>
<span class="token comment">//   SuperType.prototype.fn = ()=&gt;{}</span>
<span class="token comment">//   //继承</span>
<span class="token comment">//   function SubType(name){</span>
<span class="token comment">//     // 属性继承</span>
<span class="token comment">//     SuperType.call(this,name)</span>
<span class="token comment">//   }</span>
<span class="token comment">//     // 方法继承 </span>
<span class="token comment">//   SubType.prototype = new SuperType()</span>
<span class="token comment">//   SubType.prototype.constructor = SubType</span>
<span class="token comment">//   SubType.prototype.fn1 = ()=&gt;{}</span>
<span class="token comment">//   // 缺点 SuperType 会执行2次</span>
</code></pre></div><ul><li>4、原型式继承</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//   条件 必须要有一个对象可以作为另一个对象的数据, 通过 Object.create() 函数 </span>
<span class="token comment">//       第一个是接受的对象 第二个是对对象属性的描述(与Object.defineProperties()第二个参数一样)</span>
<span class="token comment">//   let person = {</span>
<span class="token comment">//     name:'sg',</span>
<span class="token comment">//     age:18</span>
<span class="token comment">//   }</span>
<span class="token comment">//   // Object.create用法 可以接受2个参数</span>
<span class="token comment">//   let obj = Object.create(person,{</span>
<span class="token comment">//     name:{</span>
<span class="token comment">//       values:'xxx'</span>
<span class="token comment">//     }</span>
<span class="token comment">//   })</span>
<span class="token comment">//   使用场景  让一个对象跟另一个对象保持相似的情况下</span>
</code></pre></div><ul><li>5、寄生组合式继承</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//   function fn(subType,superType){</span>
<span class="token comment">//     var p = Object(subType.protoType)</span>
<span class="token comment">//     p.constructor = subType</span>
<span class="token comment">//     subType.prototype = p</span>
<span class="token comment">//   }</span>
<span class="token comment">//   function Super(){}</span>
<span class="token comment">//   S.prototype.sayName = ()=&gt;{}</span>
  
<span class="token comment">//   function Sub(name,age){</span>
<span class="token comment">//     Super.call(this)</span>
<span class="token comment">//     this.age = age</span>
<span class="token comment">//   }</span>
<span class="token comment">//   // 将原型挂载上去</span>
<span class="token comment">//   p(Sub,Super)</span>
<span class="token comment">//   Sub.prototype.fn1 = ()=&gt;{}</span>
</code></pre></div><h2 id="函数-2"><a href="#函数-2" aria-hidden="true" class="header-anchor">#</a> 函数</h2> <ul><li>有两种方式定义:函数声明和函数表达式
<ul><li>函数声明 特征 函数声明提升(函数表达式不会)</li></ul></li> <li>递归
<ul><li>这种情况下要回调函数自身,如果是匿名函数可以通过 arguments.callee(指向的就是当前函数),严格模式下报错,可以用函数表达式</li></ul></li></ul> <h2 id="闭包"><a href="#闭包" aria-hidden="true" class="header-anchor">#</a> 闭包</h2> <ul><li>定义:指有权访问另一个函数作用域的变量的函数</li></ul> <h2 id="this"><a href="#this" aria-hidden="true" class="header-anchor">#</a> this</h2> <ul><li>this对象是在运行时基于函数的执行环境绑定,但是匿名函数的执行环境具有全局性,指向的是window</li> <li>例子 非严格模式下</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 1、  var name = 'the window'</span>
  <span class="token comment">//   var obj = {</span>
  <span class="token comment">//     name:'my obj'</span>
  <span class="token comment">//     fn:function(){</span>
  <span class="token comment">//       return this.name</span>
  <span class="token comment">//     }</span>
  <span class="token comment">//   }</span>
  <span class="token comment">//   obj.fn() //'my obj'</span>
  <span class="token comment">//   obj.fn = obj.fn //'the window'</span>
  <span class="token comment">// 2、var name = 'the window'</span>
  <span class="token comment">// var obj = {</span>
  <span class="token comment">//   name : 'my obj',</span>
  <span class="token comment">//   fn:function(){</span>
  <span class="token comment">//     return function(){</span>
  <span class="token comment">//       return this.name</span>
  <span class="token comment">//     }</span>
  <span class="token comment">//   }</span>
  <span class="token comment">// }</span>
  <span class="token comment">// obj.fn()() //the window  </span>
</code></pre></div><h2 id="window"><a href="#window" aria-hidden="true" class="header-anchor">#</a> window</h2> <ul><li>它作为全局对象的根 所有的全局变量和方法都放在他下面</li> <li>delete</li></ul> <blockquote><p>能删除 window.a = 'xx'(或者 a = 'xx') ;delete window.a  a=&gt;undefined  因为window 属性有个[[configurable]] 为false
但是不能删除 var a = '1'; delete window.a  a=&gt;1</p></blockquote> <ul><li>窗口位置</li></ul> <blockquote><p>screentX/screentY screentLeft/screentTop</p></blockquote> <ul><li>窗口大小</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// outerHeight/outerWidth 浏览器所有的宽高(包括边框等能看到的东西)</span>
<span class="token comment">// innerHeight/innerWidth 浏览器可视区的宽高</span>
<span class="token comment">// window.open($1,$2,$3)</span>
<span class="token comment">//   $1</span>
<span class="token comment">//     url</span>
<span class="token comment">//   $2 </span>
<span class="token comment">//     _blank - URL加载到一个新的窗口。这是默认</span>
<span class="token comment">//     _parent - URL加载到父框架</span>
<span class="token comment">//     _self - URL替换当前页面</span>
<span class="token comment">//     _top - URL替换任何可加载的框架集</span>
<span class="token comment">//     name - 窗口名称</span>
<span class="token comment">//   $3 窗口的大小 当有值的时候 _blank 在新的页面中打开</span>
<span class="token comment">//     height/width/top/left 等 </span>
<span class="token comment">//   注意 let w = window.open($1,$2,$3)  要将w.opener=null 因为新窗口的opener 指向当前window </span>
<span class="token comment">//       a 标签也是也有问题 处理：添加noopener 属性</span>
<span class="token comment">//       通过 window.opener.location = newURL 来修改原来网页的url    </span>
</code></pre></div><ul><li>系统对话框</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// alert() 弹出框</span>
<span class="token comment">// confirm() 显示 确认 和 取消 有返回值</span>
<span class="token comment">// prompt() 显示 确认 和 取消 自带一个输入框 有返回值</span>
</code></pre></div><ul><li>location</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// window.location和document.location 应用的是同一个对象</span>
<span class="token comment">//     hash      '#xxxx'</span>
<span class="token comment">//     host      'www.xxx.com:80'</span>
<span class="token comment">//     hostname  'wwww.xxx.com'</span>
<span class="token comment">//     href      'http://www.xxx.com'  完整的url  location.toString 也返回这个</span>
<span class="token comment">//     pathname  '/xxx/'</span>
<span class="token comment">//     port      '8080'</span>
<span class="token comment">//     protocol  'http:'</span>
<span class="token comment">//     search    '?q=x'    </span>
<span class="token comment">//     操作 </span>
<span class="token comment">//       下面3个方法 都一样 跳转URL</span>
<span class="token comment">//       location.assign('xxxx')  window.location='xx'  location.href='xx' </span>
<span class="token comment">//     以上操作 除了hash 其他的设置修改 都会触发浏览器的重新加载</span>
<span class="token comment">//     以上所有操作都会产生一条记录  但是使用replace('只接受一个参数') 不会产生记录</span>
<span class="token comment">//     location.reload() //重新加载 (可能走缓存) </span>
<span class="token comment">//     location.reload(true) //重新加载 (从服务器重新加载) \</span>
</code></pre></div><ul><li>navigator</li> <li>记录浏览器的信息</li> <li>1、检查插件 主要plugins 每个里面的name(IE不支持,书上有暂时不记录了)</li> <li>navigator.plugins</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// function hasPlugin(name){</span>
<span class="token comment">//   name = name.toLowerCase();</span>
<span class="token comment">//   for(let i=0;i&lt;navigator.plugins.length;i++){</span>
<span class="token comment">//     if(navigator.plugins[i].name.toLowerCase().indexOf(name)&gt;-1){</span>
<span class="token comment">//       return true</span>
<span class="token comment">//     }</span>
<span class="token comment">//   }</span>
<span class="token comment">// }</span>
<span class="token comment">// hasPlugin('Flash')</span>
</code></pre></div><ul><li>2、浏览器信息</li> <li>navigator.userAgent</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// screen 显示了一堆浏览器的数据(具体看书)</span>
<span class="token comment">// history 书上介绍的少</span>
<span class="token comment">//   length 属性保存着历史记录  设置为0  即情况历史记录</span>
<span class="token comment">//   go('xx') 页面跳转</span>
<span class="token comment">//   back()   向后</span>
<span class="token comment">//   forward()向前</span>
</code></pre></div><h2 id="dom"><a href="#dom" aria-hidden="true" class="header-anchor">#</a> DOM</h2> <ul><li>html 元素通过元素节点来表示,节点类型一起12个</li> <li>dom.nodeType(1 元素, 2属性, 3 文本,8 注释,9 跟节点)</li> <li>dom.nodeName 元素的标签名 只有元素节点才有</li></ul> <h3 id="节点关系"><a href="#节点关系" aria-hidden="true" class="header-anchor">#</a> 节点关系</h3> <ul><li>dom.parentNode</li> <li>dom.childNodes</li> <li>dom.previousSibling</li> <li>dom.nextSibling</li> <li>dom.firstChild</li> <li>dom.lastChild  (父元素下的第一个节点(节点和元素 是2个东西)</li> <li>dom.ownerDocument (指向当前的document(每个节点都有))</li></ul> <h3 id="节点操作"><a href="#节点操作" aria-hidden="true" class="header-anchor">#</a> 节点操作</h3> <ul><li>parentNode.appendChild(node)  往父节点内插入一个节点</li> <li>parentNode.insertBefore(node,flagNode) 一个参数 插入到第二个 目标元素 之前(若为空 效果等同于appendChild,必须有2个参数)</li> <li>parentNode.replaceChild(node1,node2) 第一个节点 替换 第二个节点</li> <li>parentNode.removeChild('node') 要移除那个节点</li> <li>以上4个操作 都是在父节点下使用,同时必须要有子节点,否则会报错(文本节点就不行)</li> <li>clone(false) 浅拷贝
<ul><li>clone(true) 浅拷贝  拷贝的时候要注意id</li></ul></li></ul> <h3 id="document"><a href="#document" aria-hidden="true" class="header-anchor">#</a> document</h3> <ul><li>body 属性 直接指向document.body</li> <li>doctype 属性来访问 &lt;!DOCTYPE html&gt; 实体</li> <li>URL  === location.href 获取完整的url</li> <li>domain === location.hostname 获取域名</li> <li>referrer 获取来源页面的URL</li> <li>特例:
<ul><li>document.domain 阔以处理同不同页面  共同主域的页面跨域</li></ul></li> <li>1、以上只有domain 可以设置值 由于跨域的考虑 只能设置URL 包含的域
<ul><li>(例如 url: p2p.xx.com(紧绷型)  =&gt; 只能设置成xx.com(松散型))</li></ul></li> <li>2、domain 一开始是松散型 就不能设置成紧绷型 过来阔以</li></ul> <h3 id="查找元素"><a href="#查找元素" aria-hidden="true" class="header-anchor">#</a> 查找元素</h3> <ul><li>getElementById()  id区别大小写</li> <li>getElementsByTagName('标签名或者*') 标签名不区分大小写 * 是匹配所有的标签(html标签也会返回,按顺序放在数组内) 动态获取的(随着标签变化)</li> <li>getElementsByName('xss') 获取name值是xss 的节点</li> <li>特例
<ul><li>document.anchors 所有带name特性的 a标签</li> <li>document.forms === document.getElementByTagName('form')</li> <li>document.images === document.getElementByTagName('img')</li> <li>document.links 所有带 href的 a标签</li> <li>写入</li> <li>write()/writeln()  都接收一个字符串 后者会默认添加一个\n
<ul><li>还阔以 动态写入 script 标签</li></ul></li> <li>open()/close() 分别用于打开和关闭网页的流输出</li></ul></li></ul> <h3 id="element"><a href="#element" aria-hidden="true" class="header-anchor">#</a> Element</h3> <ul><li>属性 id/class/title/lang/dir</li> <li>dir 值ltr(从左到右) rtl(从右到左)</li> <li>getAttribute()  不区分大小写</li></ul> <blockquote><p>获取元素的属性  自定义的也可以
另外 dom.属性 不能获取到自定义 也不区分大小写
属性获取和getAttribute方法获取 两个特例会不同</p></blockquote> <blockquote><p>1、style 属性获取返回一个对象  方法获取会返回只返回内联样式设置的
2、onclick 属性获取的是函数    方法获取的是一个onclick里面的字符串</p></blockquote> <ul><li>setAttribute()</li></ul> <blockquote><p>设置属性 属性或者setAttribute 增加的自定义属性 双方都不能获取到
方法设置的属性 会显示在html 结构中,属性增加的不会
方法设置的 不管大小写 都统一转成 小写</p></blockquote> <ul><li>removeAttribute()</li> <li>删除属性</li></ul> <blockquote><p>attributes 获取元素所有的属性 返回的是一个集合
nodeValue nodeName 某一个属性的 key和value
createElement 方法创建一个元素  不区分大小写</p></blockquote> <h3 id="文本"><a href="#文本" aria-hidden="true" class="header-anchor">#</a> 文本</h3> <ul><li>appendData('zz') 将text添加到节点的末尾</li> <li>deleteData(offset,count) 删除指定位子的 个数</li> <li>insertData(offset,text)</li> <li>replaceData(offset,count,text)</li> <li>splitText(offset) 分隔文本节点</li> <li>createTextNode 创建文本节点</li></ul> <h3 id="动态脚本"><a href="#动态脚本" aria-hidden="true" class="header-anchor">#</a> 动态脚本</h3> <ul><li>创建的脚本 阔以放到body也阔以放到head中</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span>
  <span class="token keyword">let</span> code <span class="token operator">=</span> <span class="token string">&quot;function sayHi(){alert('hi')}; sayHi()&quot;</span>
  script<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
</code></pre></div><h3 id="动态样式"><a href="#动态样式" aria-hidden="true" class="header-anchor">#</a> 动态样式</h3> <blockquote><p>只有link和style标签能够把css样式包含到html中
必须将link标签添加到head中而不是body
加载外部样式文件的过程是异步的</p></blockquote> <h3 id="选择符"><a href="#选择符" aria-hidden="true" class="header-anchor">#</a> 选择符</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// document.querySelector('选择符') 静态获取的 不会随着元素多少而变化</span>
<span class="token comment">// document.querySelectorAll('选择符')</span>
<span class="token comment">// document.childElementCount 返回子元素的个数</span>
<span class="token comment">// getElementsByClassName('') 传入class 返回目标元素 动态获取的</span>
<span class="token comment">// dom.classList 获取所有的class 是一个集合 同时阔以对他设置(传入的也是数组或者集合)</span>
<span class="token comment">//   他有一系列操作方法</span>
<span class="token comment">//   add(value) 添加列表中 值存在了就不添加了</span>
<span class="token comment">//   contains(value) 列表中是否存在</span>
<span class="token comment">//   remove(value) 从列表中删除</span>
<span class="token comment">//   toggle(value) 如果列表中有值就删除,没有就添加</span>
</code></pre></div><h3 id="焦点"><a href="#焦点" aria-hidden="true" class="header-anchor">#</a> 焦点</h3> <ul><li>document.activeElement === 触发焦点的元素</li></ul> <h3 id="readystate-属性"><a href="#readystate-属性" aria-hidden="true" class="header-anchor">#</a> readyState 属性</h3> <blockquote><p>他来实现一个指示文档已经加载完成的指示器
loading 正在加载文档
complete 加载完文档完 配合onload 事件</p></blockquote> <h3 id="浏览器模式-document-compatmode"><a href="#浏览器模式-document-compatmode" aria-hidden="true" class="header-anchor">#</a> 浏览器模式(document.compatMode)</h3> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 标准模式值 'CSS1Compat' (&lt;!DOCTYPE html&gt;)</span>
  <span class="token comment">// 混杂模式 'BackCompat'</span>
</code></pre></div><h3 id="标签自定义属性"><a href="#标签自定义属性" aria-hidden="true" class="header-anchor">#</a> 标签自定义属性</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 添加 格式 data-xxx(data-开头)</span>
<span class="token comment">// 访问 dataset.xxx</span>
</code></pre></div><h3 id="插入标记"><a href="#插入标记" aria-hidden="true" class="header-anchor">#</a> 插入标记</h3> <ul><li>innerHTML</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 只读模式:返回元素所有的子节点</span>
  <span class="token comment">// 写模式:插入的内容 会覆盖原有的子节点</span>
  <span class="token comment">// 插入 script标签(暂时没有成功)</span>
  <span class="token comment">// 插入 style标签</span>
  <span class="token comment">// dom1.innerHTML = '&lt;style type=\&quot;text/css&quot;&gt;body{background-color:red}&lt;/style&gt;'</span>
</code></pre></div><ul><li>outerHTML
<ul><li>相对innerHTML 会把自身加上去</li></ul></li> <li>insertAdjacentHTML(位子,插入的文本)
<ul><li>beforebegin 在当前元素之前插入一个紧邻的同辈元素</li> <li>afterbegin 在当前元素之下插入一个新的子元素</li> <li>beforeend 在当前元素之下插入一个新的子元素</li> <li>afterend 在当前元素之后插入一个紧邻的同辈元素</li></ul></li></ul> <h3 id="scrollintoview-作用于每一个元素"><a href="#scrollintoview-作用于每一个元素" aria-hidden="true" class="header-anchor">#</a> scrollIntoView() 作用于每一个元素</h3> <ul><li>可以让元素滑动 与浏览器顶部(true 默认)或者底部对齐(false) 聊天界面用它</li> <li>dom1.scrollIntoView(false);</li></ul> <h3 id="children-返回元素元素的子节点-文本会过滤掉"><a href="#children-返回元素元素的子节点-文本会过滤掉" aria-hidden="true" class="header-anchor">#</a> children 返回元素元素的子节点 文本会过滤掉</h3> <ul><li>与childNodes比较(childNodes 什么节点都会返回 children只会返回元素的子节点)</li></ul> <h3 id="contains-被检测的节点是后代子节点"><a href="#contains-被检测的节点是后代子节点" aria-hidden="true" class="header-anchor">#</a> contains() 被检测的节点是后代子节点</h3> <ul><li>document.documentElement.contains(document.body)//true</li></ul> <h3 id="comparedocumentposition-返回节点间的位子关系"><a href="#comparedocumentposition-返回节点间的位子关系" aria-hidden="true" class="header-anchor">#</a> compareDocumentPosition 返回节点间的位子关系</h3> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 1   无关</span>
  <span class="token comment">// 2   居前 给定节点在DOM树中位于参考节点之前</span>
  <span class="token comment">// 4   居后 给定节点在DOM树中位于参考节点之后</span>
  <span class="token comment">// 8   包含 给定节点是参考节点的祖先</span>
  <span class="token comment">// 16  被包含 给定节点是参考节点的后代</span>
  <span class="token comment">// 关系值阔以叠加(2 8,4 16 一般都是一类)</span>
</code></pre></div><h3 id="插入文本"><a href="#插入文本" aria-hidden="true" class="header-anchor">#</a> 插入文本</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// innerText 包裹子文档树中的文本 读取时候 他会按照浅入深的顺序</span>
<span class="token comment">//   写入值时,结果会删除元素的所有节点 插入节点</span>
<span class="token comment">// outerText 读取值的时候同上</span>
<span class="token comment">//   写入值时, 会把自己替换掉</span>
</code></pre></div><h2 id="dom2"><a href="#dom2" aria-hidden="true" class="header-anchor">#</a> DOM2</h2> <h3 id="style-变化"><a href="#style-变化" aria-hidden="true" class="header-anchor">#</a> style 变化</h3> <ul><li>dom.style 对象下面 有很多属性</li> <li>不包含与外部样或者嵌入样式层叠表(只有js设置 和 style 有效)</li> <li>访问元素 带-  变成驼峰大小写
<ul><li>dom.style.color</li> <li>dom.style.backgroundImage</li></ul></li> <li>设置值的是 一般要给px(单位)</li> <li>cssText 设置 访问style的css 值是字符串</li> <li>length 属性是自己设置的style 属性值 阔以通过dom.style[i] 访问到属性</li> <li>getPropertyValue 通过prop 获取value值</li></ul> <h3 id="计算样式"><a href="#计算样式" aria-hidden="true" class="header-anchor">#</a> 计算样式</h3> <ul><li>document.defaultView.getComputedStyle(dom,null)</li> <li>// 等同window.getComputedStyle(dom,null)</li> <li>第二参数处理伪元素的 null即没有 若有可以设置为':after'等</li> <li>获取元素最后的css 属性值 只读不支持修改</li></ul> <h3 id="操作样式表"><a href="#操作样式表" aria-hidden="true" class="header-anchor">#</a> 操作样式表</h3> <ul><li>检查 知否支持 DOM2</li> <li>document.implementation.hasFeature('styleSheets','2.0')</li> <li>获取样式
<ul><li>document.styleSheets 集合获取所有的</li> <li>styleDom.sheet  获取style的css属性</li></ul></li> <li>修改
<ul><li>直接对 styleDom.sheet 里面的值进行修改</li></ul></li> <li>创建
<ul><li>style.sheet.insertRule(<code>.div{ color:blue}</code>)</li></ul></li> <li>删除
<ul><li>sheet.deleteRule(0)</li></ul></li></ul> <h3 id="元素大小"><a href="#元素大小" aria-hidden="true" class="header-anchor">#</a> 元素大小</h3> <ul><li>偏移量
<ul><li>offsetHeight:元素垂直方向上占用的空间大小（包括边框）</li> <li>offsetWidth:元素水平方向上占用的空间大小（包括边框）</li> <li>offsetLeft:与父级左边框之间的距离（getElementLeft() 值相同）</li> <li>offsetTop:与父级右边框之间的距离（getElementTop() 值相同）</li> <li>clientWidth/clientHeight(不含边框的宽高)</li></ul></li> <li>滚动大小(body自带滚动,元素要加overflow)
<ul><li>scrollHeight/scrollWidth 在没有滚动时 就等于元素本身,最小值就是元素本身,主要用来确定元素内容的大小
<ul><li>带滑动的页面，高度就是documentElement.scrollHeight</li></ul></li> <li>scrollLeft/scrollTop 被隐藏左右边的像素 可以设置值</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 延时处理 不然不生效  不加单位</span>
  document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop  <span class="token operator">=</span> <span class="token string">'100'</span>
  document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollLeft  <span class="token operator">=</span> <span class="token string">'0'</span>
</code></pre></div><ul><li>dom.getBoundingClientRect() 获取元素的位子信息</li></ul> <h3 id="遍历"><a href="#遍历" aria-hidden="true" class="header-anchor">#</a> 遍历</h3> <ul><li>NodeIterator
<ul><li>document.createNodeIterator(root,whatToShow,filter,entityReferenceExpansion) 下面的遍历的用法 实际参数参考书籍</li> <li>NodeIterator 类型中只要是 nextNode()和previousNode()进行遍历,他是深度优先遍历</li></ul></li></ul> <div class="language-html extra-class"><pre class="language-html"><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>div1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">&gt;</span></span>122<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">&gt;</span></span> world!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>List item 1
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>1111111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>List item 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>List item 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">let</span> dom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#div1'</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> <span class="token function-variable function">filter</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// FILTER_ACCEPT 显示当前的信息 </span>
      <span class="token comment">// FILTER_SKIP 过滤当前的信息</span>
      <span class="token keyword">return</span> node<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'li'</span><span class="token operator">?</span> NodeFilter<span class="token punctuation">.</span><span class="token constant">FILTER_ACCEPT</span><span class="token punctuation">:</span>NodeFilter<span class="token punctuation">.</span><span class="token constant">FILTER_SKIP</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> iterator <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createNodeIterator</span><span class="token punctuation">(</span>dom<span class="token punctuation">,</span>NodeFilter<span class="token punctuation">.</span><span class="token constant">SHOW_ELEMENT</span><span class="token punctuation">,</span>filter<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> rs <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span>tagName<span class="token punctuation">)</span>
      rs <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li>TreeWalker 比 NodeIterator 高级用法参数一样,但是多了几个api
<ul><li>除了 nextNode 和 previousNode 方法之外</li> <li>parentNode</li> <li>firstChild</li> <li>lastChild</li> <li>nextSibling</li> <li>previousSibling</li></ul></li></ul> <h2 id="事件"><a href="#事件" aria-hidden="true" class="header-anchor">#</a> 事件</h2> <ul><li>事件流，'DOM2级事件'规定的事件包括三个阶段,事件捕获阶段,处理目标和事件冒泡阶段</li> <li>传播流程:1、目标在捕获开始,但是不会接收到事件。2、处于目标阶段，事件处理。3、冒泡阶段,事件又传播会文档</li></ul> <h3 id="ui事件"><a href="#ui事件" aria-hidden="true" class="header-anchor">#</a> UI事件</h3> <ul><li>load
<ul><li>1、当页面完全加载(所有资源),就会触发window上的load事件</li> <li>2、图片加载完成也会触发img上的load事件(注意,事件要在src赋值之前指定)</li> <li>3、script 动态加载js文件是否加载完毕(注意,事件和src顺序没有关系)</li></ul></li> <li>resize事件/scroll事件
<ul><li>resize，浏览器窗口调整新的高度和宽度,浏览器窗口最大小化，就会触发resize,绑定在window上(一般浏览器窗口变化了1px像素才会触发)</li> <li>scroll，浏览器滑动触发</li></ul></li></ul> <h3 id="焦点事件-还有其他的不常用具体看书"><a href="#焦点事件-还有其他的不常用具体看书" aria-hidden="true" class="header-anchor">#</a> 焦点事件(还有其他的不常用具体看书)</h3> <ul><li>blur事件 失去焦点时候发出,不会冒泡</li> <li>focus事件 聚集焦点,不会冒泡</li></ul> <h3 id="鼠标事件-具体的看书"><a href="#鼠标事件-具体的看书" aria-hidden="true" class="header-anchor">#</a> 鼠标事件(具体的看书)</h3> <ul><li>click 鼠标和enter键都可以触发</li> <li>dblclick 双击 (注意 click 和dblclick 依赖于mousedown和mouseup事件触发而触发,mousedown和mouseup不依赖别的)</li> <li>mousedown 鼠标按下任意键</li> <li>mouseenter/mouseleave 进入离开 不会冒泡</li> <li>mousemove 移入</li> <li>mouseover/mouseout 进去移除  会冒泡</li> <li>mouseup 鼠标抬起</li></ul> <h3 id="键盘事件"><a href="#键盘事件" aria-hidden="true" class="header-anchor">#</a> 键盘事件</h3> <ul><li>keydown/keypress 按下任意键 都会触发 可重复触发</li> <li>文本事件 textInput 处理文件输入框的事件,在文本变化前面触发(e.data获取输入的值)</li></ul> <h3 id="h5事件"><a href="#h5事件" aria-hidden="true" class="header-anchor">#</a> h5事件</h3> <ul><li>DOMContentLoaded事件 等待dom树形成之后就会触发,load 事件是等所有资源和dom形成之后触发</li> <li>readyStatechange事件 指元素或者文档加载状态 (只要支持他的 都有一个readyState事件,有5个阶段从促使化到加载完成具体看书)</li> <li>hashchange 事件window下的事件,只要url#后的参数变化 就会触发</li></ul> <h3 id="事件委托"><a href="#事件委托" aria-hidden="true" class="header-anchor">#</a> 事件委托</h3> <ul><li>利用事件冒泡,指定一个事件处理程序,管理某一类型的所有事件</li></ul></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">11/7/2022, 8:03:51 PM</span></div></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Study-history/front/video.html" class="prev">
          视频
        </a></span> <!----></p></div> </div> <!----></div></div>
    <script src="/Study-history/assets/js/app.a1ad6491.js" defer></script><script src="/Study-history/assets/js/35.ba4dfc73.js" defer></script>
  </body>
</html>
